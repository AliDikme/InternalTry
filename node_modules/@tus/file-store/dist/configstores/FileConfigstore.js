"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileConfigstore = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const p_queue_1 = __importDefault(require("p-queue"));
/**
 * FileConfigstore writes the `Upload` JSON metadata to disk next the uploaded file itself.
 * It uses a queue which only processes one operation at a time to prevent unsafe concurrent access.
 */
class FileConfigstore {
    constructor(path) {
        this.directory = path;
        this.queue = new p_queue_1.default({ concurrency: 1 });
    }
    async get(key) {
        try {
            const buffer = await this.queue.add(() => promises_1.default.readFile(this.resolve(key), 'utf8'));
            return JSON.parse(buffer);
        }
        catch {
            return undefined;
        }
    }
    async set(key, value) {
        await this.queue.add(() => promises_1.default.writeFile(this.resolve(key), JSON.stringify(value)));
    }
    async delete(key) {
        await this.queue.add(() => promises_1.default.rm(this.resolve(key)));
    }
    async list() {
        return this.queue.add(async () => {
            const files = await promises_1.default.readdir(this.directory, { withFileTypes: true });
            const promises = files
                .filter((file) => file.isFile() && file.name.endsWith('.json'))
                .map((file) => promises_1.default.readFile(node_path_1.default.resolve(file.path, file.name), 'utf8'));
            return Promise.all(promises);
        });
    }
    resolve(key) {
        return node_path_1.default.resolve(this.directory, `${key}.json`);
    }
}
exports.FileConfigstore = FileConfigstore;
